<div class="pod">
<!-- INDEX START -->
<h3 id="TOP">Index</h3>

<ul><li><a href="#NAME">NAME</a></li>
<li><a href="#CATEGORY">CATEGORY</a></li>
<li><a href="#SYNOPSIS">SYNOPSIS</a></li>
<li><a href="#Core_Functions">Core Functions</a>
<ul><li><a href="#get_video_surface">get_video_surface</a></li>
<li><a href="#get_video_info">get_video_info</a></li>
<li><a href="#video_driver_name">video_driver_name</a></li>
<li><a href="#list_modes">list_modes</a></li>
<li><a href="#video_mode_ok">video_mode_ok</a></li>
<li><a href="#set_video_mode">set_video_mode</a>
<ul><li><a href="#List_of_avalaibles_flags">List of avalaibles flags</a></li>
</ul>
</li>
<li><a href="#convert_surface">convert_surface</a></li>
<li><a href="#display_format">display_format</a></li>
<li><a href="#display_format_alpha">display_format_alpha</a></li>
<li><a href="#load_BMP">load_BMP</a></li>
<li><a href="#save_BMP">save_BMP</a></li>
<li><a href="#set_color_key">set_color_key</a></li>
<li><a href="#set_alpha">set_alpha</a></li>
<li><a href="#fill_rect">fill_rect</a></li>
</ul>
</li>
<li><a href="#Surface_Locking_and_Unlocking">Surface Locking and Unlocking</a>
<ul><li><a href="#lock_surface">lock_surface</a></li>
<li><a href="#unlock_surface">unlock_surface</a></li>
<li><a href="#MUSTLOCK">MUSTLOCK</a></li>
</ul>
</li>
<li><a href="#Screen_Updating_Functions">Screen Updating Functions</a>
<ul><li><a href="#set_clip_rect">set_clip_rect</a></li>
<li><a href="#get_clip_rect">get_clip_rect</a></li>
<li><a href="#blit_surface">blit_surface</a></li>
<li><a href="#update_rect">update_rect</a></li>
<li><a href="#update_rects">update_rects</a></li>
<li><a href="#flip">flip</a></li>
</ul>
</li>
<li><a href="#Palette_Color_and_Pixel_Functions">Palette, Color and Pixel Functions</a>
<ul><li><a href="#set_colors">set_colors</a></li>
<li><a href="#set_palette">set_palette</a></li>
<li><a href="#set_gamma">set_gamma</a></li>
<li><a href="#get_gamma_ramp">get_gamma_ramp</a></li>
<li><a href="#set_gamma_ramp">set_gamma_ramp</a></li>
<li><a href="#map_RGB">map_RGB</a></li>
<li><a href="#map_RGBA">map_RGBA</a></li>
<li><a href="#get_RGB">get_RGB</a></li>
<li><a href="#get_RGBA">get_RGBA</a></li>
</ul>
</li>
<li><a href="#GL_Methods">GL Methods</a>
<ul><li><a href="#GL_load_library">GL_load_library</a></li>
<li><a href="#GL_get_proc_address">GL_get_proc_address</a></li>
<li><a href="#GL_get_attribute">GL_get_attribute</a></li>
<li><a href="#GL_set_attribute">GL_set_attribute</a></li>
<li><a href="#GL_swap_buffers">GL_swap_buffers</a></li>
</ul>
</li>
<li><a href="#Video_Overlay_Functions">Video Overlay Functions</a>
<ul><li><a href="#lock_YUV_overlay">lock_YUV_overlay</a></li>
<li><a href="#unlock_YUV_overlay">unlock_YUV_overlay</a></li>
<li><a href="#display_YUV_overlay">display_YUV_overlay</a></li>
</ul>
</li>
<li><a href="#Window_Management_Functions">Window Management Functions</a>
<ul><li><a href="#wm_set_caption">wm_set_caption</a></li>
<li><a href="#wm_get_caption">wm_get_caption</a></li>
<li><a href="#wm_set_icon">wm_set_icon</a></li>
<li><a href="#wm_grab_input">wm_grab_input</a></li>
<li><a href="#wm_iconify_window">wm_iconify_window</a></li>
<li><a href="#wm_toggle_fullscreen">wm_toggle_fullscreen</a></li>
</ul>
</li>
<li><a href="#AUTHOR">AUTHOR</a></li>
<li><a href="#SEE_ALSO">SEE ALSO</a>
<ul><li><a href="#Category_Objects">Category Objects</a>
</li>
</ul>
</li>
</ul><hr />
<!-- INDEX END --><a href="assets/Video.png" target="_blank"><img src="assets/Video.png" style="height: 160px" alt="Video.png"/></a><a href="assets/Video_lock_surface.png" target="_blank"><img src="assets/Video_lock_surface.png" style="height: 160px" alt="Video_lock_surface.png"/></a><hr />

<h1 id="NAME">NAME</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="NAME_CONTENT">
<p>SDL::Video - Bindings to the video category in SDL API</p>

</div>
<h1 id="CATEGORY">CATEGORY</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="CATEGORY_CONTENT">
<p>Core, Video</p>

</div>
<h1 id="SYNOPSIS">SYNOPSIS</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="SYNOPSIS_CONTENT">
<pre> use SDL;
 use SDL::Video;
 use SDL::Surface;
 use SDL::Rect;

 # the size of the window box or the screen resolution if fullscreen
 my $screen_width   = 800;
 my $screen_height  = 600;

 SDL::init(SDL_INIT_VIDEO);

 # setting video mode
 my $screen_surface = SDL::Video::set_video_mode($screen_width, $screen_height, 32, SDL_SWSURFACE);

 # drawing something somewhere
 my $mapped_color   = SDL::Video::map_RGB($screen_surface-&gt;format(), 0, 0, 255); # blue
 SDL::Video::fill_rect($screen_surface, 
                       SDL::Rect-&gt;new($screen_width / 4, $screen_height / 4, 
                                      $screen_width / 2, $screen_height / 2), $mapped_color);

 # update an area on the screen so its visible
 SDL::Video::update_rect($screen_surface, 0, 0, $screen_width, $screen_height);

 sleep(5); # just to have time to see it

 SDL::quit();

</pre>

</div>
<h1 id="Core_Functions">Core Functions</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="Core_Functions_CONTENT">

</div>
<h2 id="get_video_surface">get_video_surface</h2>
<div id="get_video_surface_CONTENT">
<pre> my $surface = SDL::Video::get_video_surface();

</pre>
<p>This function returns the current display <a href="SDL-Surface">SDL::Surface</a>. If SDL is doing format conversion on the display surface, this 
function returns the publicly visible surface, not the real video surface.</p>
<p>Example:</p>
<pre> # somewhere after you set the video mode
 my $surface = SDL::Video::get_video_surface();

 printf( &quot;our screen is %d pixels wide and %d pixels high\n&quot;, $surface-&gt;w, $surface-&gt;h );

</pre>

</div>
<h2 id="get_video_info">get_video_info</h2>
<div id="get_video_info_CONTENT">
<pre> my $video_info = SDL::Video::get_video_info();

</pre>
<p>This function returns a read-only <a href="SDL-VideoInfo">SDL::VideoInfo</a> containing information about the video hardware. If it is called before 
<a href="#set_video_mode">SDL::Video::set_video_mode</a>, the <code>vfmt</code> member of the returned structure will contain the pixel 
format of the <strong>best</strong> video mode. </p>
<p>Example:</p>
<pre> use SDL;
 use SDL::Video;
 use SDL::VideoInfo;
 use SDL::PixelFormat;

 SDL::init(SDL_INIT_VIDEO);

 my $video_info = SDL::Video::get_video_info();

 printf( &quot;we can have %dbits per pixel\n&quot;, $video_info-&gt;vfmt-&gt;BitsPerPixel );

 SDL::quit();

</pre>

</div>
<h2 id="video_driver_name">video_driver_name</h2>
<div id="video_driver_name_CONTENT">
<pre> my $driver_name = SDL::Video::video_driver_name();

</pre>
<p>This function will return the name of the initialized video driver up to a maximum of 1024 characters. The driver name is a simple one 
word identifier like <code>&quot;x11&quot;</code>, <code>&quot;windib&quot;</code> or <code>&quot;directx&quot;</code>.</p>
<p><strong>Note</strong>: Some platforms allow selection of the video driver through the <code>SDL_VIDEODRIVER</code> environment variable. </p>
<p>Example:</p>
<pre> use SDL;
 use SDL::Video;

 SDL::init(SDL_INIT_VIDEO);

 print SDL::Video::video_driver_name() . &quot;\n&quot;;

 SDL::quit();

</pre>

</div>
<h2 id="list_modes">list_modes</h2>
<div id="list_modes_CONTENT">
<pre> my @modes = @{ SDL::Video::list_modes( $pixel_format, $flags ) };

</pre>
<p>Returns a ref to an array of available screen dimensions for the given format and video flags,
or it return undef if no modes are available.</p>
<p>Example:</p>
<pre> use SDL;
 use SDL::Video;
 use SDL::VideoInfo;
 use SDL::PixelFormat;
 use SDL::Rect;

 SDL::init(SDL_INIT_VIDEO);

 my $video_info = SDL::Video::get_video_info();

 my @modes = @{ SDL::Video::list_modes($video_info-&gt;vfmt, SDL_NOFRAME) };

 if($#modes &gt; 0)
 {
     print(&quot;available modes:\n&quot;);
     foreach my $index ( @modes )
     {
         printf(&quot;%03d: %d x %d\n&quot;, $index, $modes[$index]-&gt;w, $modes[$index]-&gt;h );
     }
 }
 elsif($#modes == 0)
 {
     printf(&quot;%s video modes available\n&quot;, $modes[0]);
 }

 SDL::quit();

</pre>

</div>
<h2 id="video_mode_ok">video_mode_ok</h2>
<div id="video_mode_ok_CONTENT">
<pre> my $bpp_ok = SDL::Video::video_mode_ok( $width, $height, $bpp, $flags );

</pre>
<p>This function is used to check whether the requested mode is supported by the current video device. The arguments passed to this function 
are the same as those you would pass to <a href="#set_video_mode">SDL::Video::set_video_mode</a>. 
It returns <code>0</code> if the mode is not supported at all, otherwise the suggested <code>bpp</code>.</p>
<p>Example:</p>
<pre> use SDL;
 use SDL::Video;

 SDL::init(SDL_INIT_VIDEO);

 my $video_mode_ok = SDL::Video::video_mode_ok( 800, 600, 32, SDL_SWSURFACE );

 unless($video_mode_ok)
 {
     printf( &quot;this video mode is not supported\n&quot; );
 }

 SDL::quit();

</pre>

</div>
<h2 id="set_video_mode">set_video_mode</h2>
<div id="set_video_mode_CONTENT">
<pre> my $surface = SDL::Video::set_video_mode( 800, 600, 32, SDL_SWSURFACE|SDL_DOUBLEBUF|SDL_FULLSCREEN);

</pre>
<p>Sets up a video mode with the specified width, height, bits-per-pixel and flags. 
<code>set_video_mode</code> returns a <a href="SDL-Surface">SDL::Surface</a> on success otherwise it returns undef on error, the error message is retrieved 
using <code>SDL::get_error</code>.</p>

</div>
<h3 id="List_of_avalaibles_flags">List of avalaibles flags</h3>
<div id="List_of_avalaibles_flags_CONTENT">
<dl>
	<dt><code>SDL_SWSURFACE</code></dt>
	<dd>
		<p>Create the video surface in system memory</p>
	</dd>
	<dt><code>SDL_HWSURFACE</code></dt>
	<dd>
		<p>Create the video surface in video memory</p>
	</dd>
	<dt><code>SDL_ASYNCBLIT</code></dt>
	<dd>
		<p>Enables the use of asynchronous updates of the display surface. 
This will usually slow down blitting on single CPU machines, but may provide a speed increase on SMP systems.</p>
	</dd>
	<dt><code>SDL_ANYFORMAT</code></dt>
	<dd>
		<p>Normally, if a video surface of the requested bits-per-pixel (bpp) is not available, SDL will emulate one with a shadow surface.
Passing <code>SDL_ANYFORMAT</code> prevents this and causes SDL to use the video surface, regardless of its pixel depth.</p>
	</dd>
	<dt><code>SDL_HWPALETTE</code></dt>
	<dd>
		<p>Give SDL exclusive palette access. Without this flag you may not always get the colors you request with SDL::set_colors or SDL::set_palette.</p>
	</dd>
	<dt><code>SDL_DOUBLEBUF</code></dt>
	<dd>
		<p>Enable hardware double buffering; only valid with <code>SDL_HWSURFACE</code>. Calling <a href="#flip">SDL::Video::flip</a> will flip the buffers and update 
the screen. 
All drawing will take place on the surface that is not displayed at the moment. 
If double buffering could not be enabled then <a href="#flip">SDL::Video::flip</a> will just perform a 
<a href="#update_rect">SDL::Video::update_rect</a> on the entire screen.</p>
	</dd>
	<dt><code>SDL_FULLSCREEN</code></dt>
	<dd>
		<p>SDL will attempt to use a fullscreen mode. If a hardware resolution change is not possible (for whatever reason), 
the next higher resolution will be used and the display window centered on a black background.</p>
	</dd>
	<dt><code>SDL_OPENGL</code></dt>
	<dd>
		<p>Create an OpenGL rendering context. You should have previously set OpenGL video attributes with 
<a href="#GL_set_attribute">SDL::Video::GL_set_attribute</a>.</p>
	</dd>
	<dt><code>SDL_OPENGLBLIT</code></dt>
	<dd>
		<p>Create an OpenGL rendering context, like above, but allow normal blitting operations. 
The screen (2D) surface may have an alpha channel, and SDL::update_rects must be used for updating changes to the screen surface. 
NOTE: This option is kept for compatibility only, and will be removed in next versions. Is not recommended for new code.</p>
	</dd>
	<dt><code>SDL_RESIZABLE</code></dt>
	<dd>
		<p>Create a resizable window. 
When the window is resized by the user a <code>SDL_VIDEORESIZE</code> event is generated and 
<a href="#set_video_mode">SDL::Video::set_video_mode</a> can be called again with the new size.</p>
	</dd>
	<dt><code>SDL_NOFRAME</code></dt>
	<dd>
		<p>If possible, SDL_NOFRAME causes SDL to create a window with no title bar or frame decoration. 
Fullscreen modes automatically have this flag set.</p>
	</dd>
</dl>
<p><strong>Note 1</strong>: Use <code>SDL_SWSURFACE</code> if you plan on doing per-pixel manipulations, or blit surfaces with alpha channels, and require a high framerate. 
When you use hardware surfaces (by passing the flag <code>SDL_HWSURFACE</code> as parameter), SDL copies the surfaces from video memory to system memory 
when you lock them, and back when you unlock them. This can cause a major performance hit. Be aware that you may request a hardware surface, 
but receive a software surface because the video driver doesn't support hardware surface. Many platforms can only provide a hardware surface 
when using <code>SDL_FULLSCREEN</code>. The <code>SDL_HWSURFACE</code> flag is best used when the surfaces you'll be blitting can also be stored in video memory.</p>
<p><strong>Note 2</strong>: If you want to control the position on the screen when creating a windowed surface, you may do so by setting the environment 
variables <code>SDL_VIDEO_CENTERED=center</code> or <code>SDL_VIDEO_WINDOW_POS=x,y</code>. You can also set them via <code>SDL::putenv</code>.</p>
<p><strong>Note 3</strong>: This function should be called in the main thread of your application.</p>
<p><strong>User note 1</strong>: Some have found that enabling OpenGL attributes like <code>SDL_GL_STENCIL_SIZE</code> (the stencil buffer size) before the video mode has 
been set causes the application to simply ignore those attributes, while enabling attributes after the video mode has been set works fine.</p>
<p><strong>User note 2</strong>: Also note that, in Windows, setting the video mode resets the current OpenGL context. You must execute again the OpenGL 
initialization code (set the clear color or the shade model, or reload textures, for example) after calling SDL::set_video_mode. In Linux, 
however, it works fine, and the initialization code only needs to be executed after the first call to 
<a href="#set_video_mode">SDL::Video::set_video_mode</a> (although there is no harm in executing the initialization code after 
each call to <a href="#set_video_mode">SDL::Video::set_video_mode</a>, for example for a multiplatform application). </p>

</div>
<h2 id="convert_surface">convert_surface</h2>
<div id="convert_surface_CONTENT">
<pre> $converted_surface = SDL::Video::convert_surface( $surface, $format, $flags );

</pre>
<p>Creates a new SDL::surface of the specified <a href="SDL-PixelFormat">SDL::PixelFormat</a>, and then copies and maps the given surface to it. 
It is also useful for making a copy of a surface.</p>
<p>The flags parameter is passed to <a href="SDL-Surface">SDL::Surface</a><code>-&gt;new</code> and has those semantics.
This function is used internally by <a href="#display_format">SDL::Video::display_format</a>.
This function can only be called after <code>SDL::init</code>. </p>
<p>it returns a <a href="SDL-Surface">SDL::Surface</a> on success or <code>undef</code> on error.</p>

</div>
<h2 id="display_format">display_format</h2>
<div id="display_format_CONTENT">
<pre> $new_surface = SDL::Video::display_format( $surface );

</pre>
<p>This function takes a surface and copies it to a new surface of the pixel format and colors of the video framebuffer, suitable for fast 
blitting onto the display surface. It calls <a href="#conver_surface">SDL::Video::convert_surface</a>.</p>
<p>If you want to take advantage of hardware colorkey or alpha blit acceleration, you should set the colorkey and alpha value before calling 
this function.</p>
<p>If you want an alpha channel, see <code>SDL::Video::display_format_alpha</code>.
Return Value</p>
<p><strong>Note</strong>: Remember to use a different variable for the returned surface, otherwise you have a memory leak, since the original surface isn't freed. </p>

</div>
<h2 id="display_format_alpha">display_format_alpha</h2>
<div id="display_format_alpha_CONTENT">
<pre> $new_surface = SDL::Video::display_format_alpha( $surface );

</pre>
<p>This function takes a surface and copies it to a new surface of the pixel format and colors of the video framebuffer plus an alpha channel, 
suitable for fast blitting onto the display surface. It calls <a href="#convert_surface">SDL::Video::convert_surface</a>.</p>
<p>If you want to take advantage of hardware colorkey or alpha blit acceleration, you should set the colorkey and alpha value before calling 
this function.</p>
<p>This function can be used to convert a colorkey to an alpha channel, if the <code>SDL_SRCCOLORKEY</code> flag is set on the surface. The generated 
surface will then be transparent (alpha=0) where the pixels match the colorkey, and opaque (alpha=255) elsewhere.</p>
<p><strong>Note</strong>: The video surface must be initialised using <a href="#set_video_mode">SDL::Video::set_video_mode</a> before this function is called, or it will 
segfault.</p>

</div>
<h2 id="load_BMP">load_BMP</h2>
<div id="load_BMP_CONTENT">
<pre> $surface = SDL::Video::load_BMP( $filename );

</pre>
<p>Loads a <a href="SDL-Surface">SDL::Surface</a> from a named Windows BMP file.
<code>SDL::Video::load_BMP</code> returns a <a href="SDL-Surface">SDL::Surface</a> on success or <code>undef</code> on error.</p>
<p><strong>Note</strong>: When loading a 24-bit Windows BMP file, pixel data points are loaded as blue, green, red, and NOT red, green, blue (as one might expect). </p>
<pre> use SDL;
 use SDL::Video;
 use SDL::Rect;
 use SDL::Surface;

 my $screen_width  = 640;
 my $screen_height = 480;

 SDL::init(SDL_INIT_VIDEO);

 my $screen  = SDL::Video::set_video_mode($screen_width, $screen_height, 32, SDL_SWSURFACE);

 my $picture = SDL::Video::load_BMP('test.bmp');

 die(SDL::get_error) unless $picture;

 my $rect    = SDL::Rect-&gt;new(0, 0, $screen_width, $screen_height);

 SDL::Video::blit_surface( $picture, SDL::Rect-&gt;new(0, 0, $picture-&gt;w, $picture-&gt;h), 
                           $screen,  SDL::Rect-&gt;new(0, 0, $screen-&gt;w,  $screen-&gt;h) );

 SDL::Video::update_rect( $screen, 0, 0, $screen_width, $screen_height );

 sleep(2);

 SDL::quit;

</pre>

</div>
<h2 id="save_BMP">save_BMP</h2>
<div id="save_BMP_CONTENT">
<pre> $saved_BMP = SDL::Video::save_BMP( $surface, $filename );

</pre>
<p>Saves the given <a href="SDL-Surface">SDL::Surface</a> as a Windows BMP file named filename. 
it returns 0 on success or -1 on error.</p>

</div>
<h2 id="set_color_key">set_color_key</h2>
<div id="set_color_key_CONTENT">
<pre> $set_color_key = SDL::Video::set_color_key( $surface, $flag, $key );

</pre>
<p>Sets the color key (transparent pixel) in a blittable surface and enables or disables RLE blit acceleration.</p>
<p>RLE acceleration can substantially speed up blitting of images with large horizontal runs of transparent pixels (i.e., pixels that match 
the key value).
The key must be of the same pixel format as the surface, <a href="#map_RGB">SDL::Video::map_RGB</a> is often useful for obtaining an acceptable value.
If flag is <code>SDL_SRCCOLORKEY</code> then key is the transparent pixel value in the source image of a blit.</p>
<p>If <code>flag</code> is OR'd with <code>SDL_RLEACCEL</code> then the surface will be drawn using RLE acceleration when drawn with SDL::Blit_surface.
The surface will actually be encoded for RLE acceleration the first time <a href="#blit_surface">SDL::Video::blit_surface</a> or 
<code>SDL::Video::display_format|/display_format</code> is called on the surface.
If <code>flag</code> is <code>0</code>, this function clears any current color key. </p>
<p><code>SDL::Video::set_color_key</code> returns <code>0</code> on success or <code>-1</code> on error.</p>

</div>
<h2 id="set_alpha">set_alpha</h2>
<div id="set_alpha_CONTENT">
<pre> $set_alpha = SDL::Video::set_alpha( $surface, $flag, $key );

</pre>
<p><code>set_alpha</code> is used for setting the per-surface alpha value and/or enabling and disabling alpha blending.</p>
<p>The surface parameter specifies which SDL::surface whose alpha attributes you wish to adjust. 
flags is used to specify whether alpha blending should be used ( <code>SDL_SRCALPHA</code> ) and whether the surface should use RLE acceleration for 
blitting ( <code>SDL_RLEACCEL</code> ). 
flags can be an OR'd combination of these two options, one of these options or <code>0</code>. 
If <code>SDL_SRCALPHA</code> is not passed as a flag then all alpha information is ignored when blitting the surface. 
The alpha parameter is the per-surface alpha value; a surface need not have an alpha channel to use per-surface alpha and blitting can 
still be accelerated with <code>SDL_RLEACCEL</code>.</p>
<p><strong>Note</strong>: The per-surface alpha value of 128 is considered a special case and is optimised, so it's much faster than other per-surface values.</p>
<p>Alpha affects surface blitting in the following ways: </p>
<dl>
	<dt>RGBA-&gt;RGB with <code>SDL_SRCALPHA</code></dt>
	<dd>
		<p>The source is alpha-blended with the destination, using the alpha channel. 
SDL_SRCCOLORKEY and the per-surface alpha are ignored.</p>
	</dd>
	<dt>RGBA-&gt;RGB without <code>SDL_SRCALPHA</code></dt>
	<dd>
		<p>The RGB data is copied from the source. The source alpha channel and the per-surface alpha value are ignored. 
If SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied.</p>
	</dd>
	<dt>RGB-&gt;RGBA with <code>SDL_SRCALPHA</code></dt>
	<dd>
		<p>The source is alpha-blended with the destination using the per-surface alpha value. 
If SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied. 
The alpha channel of the copied pixels is set to opaque.</p>
	</dd>
	<dt>RGB-&gt;RGBA without <code>SDL_SRCALPHA</code></dt>
	<dd>
		<p>The RGB data is copied from the source and the alpha value of the copied pixels is set to opaque. 
If SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied.</p>
	</dd>
	<dt>RGBA-&gt;RGBA with <code>SDL_SRCALPHA</code></dt>
	<dd>
		<p>The source is alpha-blended with the destination using the source alpha channel. 
The alpha channel in the destination surface is left untouched. SDL_SRCCOLORKEY is ignored.</p>
	</dd>
	<dt>RGBA-&gt;RGBA without <code>SDL_SRCALPHA</code></dt>
	<dd>
		<p>The RGBA data is copied to the destination surface.
If SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied.</p>
	</dd>
	<dt>RGB-&gt;RGB with <code>SDL_SRCALPHA</code></dt>
	<dd>
		<p>The source is alpha-blended with the destination using the per-surface alpha value. 
If SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied.</p>
	</dd>
	<dt>RGB-&gt;RGB without <code>SDL_SRCALPHA</code></dt>
	<dd>
		<p>The RGB data is copied from the source. 
If SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied.</p>
	</dd>
</dl>
<p><strong>Note</strong>: When blitting, the presence or absence of <code>SDL_SRCALPHA</code> is relevant only on the source surface, not the destination.
<strong>Note</strong>: Note that RGBA-&gt;RGBA blits (with <code>SDL_SRCALPHA</code> set) keep the alpha of the destination surface. This means that you cannot compose 
two arbitrary RGBA surfaces this way and get the result you would expect from &quot;overlaying&quot; them; the destination alpha will work as a mask.</p>
<p><strong>Note</strong>: Also note that per-pixel and per-surface alpha cannot be combined; the per-pixel alpha is always used if available. </p>
<p><code>SDL::Video::set_alpha</code> returns <code>0</code> on success or <code>-1</code> on error.</p>

</div>
<h2 id="fill_rect">fill_rect</h2>
<div id="fill_rect_CONTENT">
<pre> $fill_rect = SDL::Video::fill_rect( $dest, $dest_rect, $pixel );

</pre>
<p>This function performs a fast fill of the given <a href="SDL-Rect">SDL::Rect</a> with the given <a href="SDL-PixelFormat">SDL::PixelFormat</a>. If dest_rect is NULL, the whole surface 
will be filled with color.</p>
<p>The color should be a pixel of the format used by the surface, and can be generated by the <a href="#map_RGB">SDL::Video::map_RGB</a> or 
<code>SDL::Video::map_RGBA|/map_RGBA</code> functions. If the color value contains an alpha value then the destination is simply &quot;filled&quot; with that 
alpha information, no blending takes place.</p>
<p>If there is a clip rectangle set on the destination (set via <a href="#set_clip_rect">SDL::Video::set_clip_rect</a>), then this function will clip based 
on the intersection of the clip rectangle and the dstrect rectangle, and the dstrect rectangle will be modified to represent the area actually 
filled.</p>
<p>If you call this on the video surface (ie: the value of <a href="#get_video_surface">SDL::Video::get_video_surface</a>) you may have to update the video 
surface to see the result. This can happen if you are using a shadowed surface that is not double buffered in Windows XP using build 1.2.9. </p>
<p><code>SDL::Video::fill_rect</code> returns <code>0</code> on success or <code>-1</code> on error.</p>
<p>for an example see <a href="#SYNOPSIS">SYNOPSIS</a>.</p>

</div>
<h1 id="Surface_Locking_and_Unlocking">Surface Locking and Unlocking</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="Surface_Locking_and_Unlocking_CONTEN">

</div>
<h2 id="lock_surface">lock_surface</h2>
<div id="lock_surface_CONTENT">
<pre> int SDL::Video::lock_surface( $surface );

</pre>
<p><code>SDL::Video::lock_surface</code> sets up the given <a href="SDL-Surface">SDL::Surface</a> for directly accessing the pixels.
Between calls to SDL::lock_surface and SDL::unlock_surface, you can write to ( <code>surface-</code>set_pixels&gt;) and read from ( <code>surface-</code>get_pixels&gt; ), 
using the pixel format stored in <code>surface-</code>format&gt;. 
Once you are done accessing the surface, you should use <a href="#unlock_surface">SDL::Video::unlock_surface</a> to release the lock.</p>
<p>Not all surfaces require locking. If <a href="#MUSTLOCK">SDL::Video::MUSTLOCK</a> evaluates to <code>0</code>, then reading and writing pixels to the surface can 
be performed at any time, and the pixel format of the surface will not change.
No operating system or library calls should be made between the lock/unlock pairs, as critical system locks may be held during this time.
<code>SDL::Video::lock_surface</code> returns <code>0</code> on success or <code>-1</code> on error.</p>
<p><strong>Note</strong>: Since SDL 1.1.8, the surface locks are recursive. This means that you can lock a surface multiple times, but each lock must have 
a matching unlock.</p>
<pre> use strict;
 use warnings;
 use Carp;

 use SDL v2.3;
 use SDL::Video;
 use SDL::Event;
 use SDL::Events;
 use SDL::Surface;

 my $screen;

 sub putpixel
 {
     my($x, $y, $color) = @_;
     my $lineoffset     = $y * ($screen-&gt;pitch / 4);
     $screen-&gt;set_pixels( $lineoffset+ $x, $color);
 }

 sub render
 {
     if( SDL::Video::MUSTLOCK( $screen) )
     {
         return if (SDL::Video::lock_surface( $screen ) &lt; 0)
     }

     my $ticks                = SDL::get_ticks();
     my ($i, $y, $yofs, $ofs) = (0,0,0,0);
     for ($i = 0; $i &lt; 480; $i++)
     {
         for (my $j = 0, $ofs = $yofs; $j &lt; 640; $j++, $ofs++)
         {
             $screen-&gt;set_pixels( $ofs, (  $i * $i + $j * $j + $ticks ) );
         }
         $yofs += $screen-&gt;pitch / 4;
     }

     putpixel(10, 10, 0xff0000);
     putpixel(11, 10, 0xff0000);
     putpixel(10, 11, 0xff0000);
     putpixel(11, 11, 0xff0000);

     SDL::Video::unlock_surface($screen) if (SDL::Video::MUSTLOCK($screen));

     SDL::Video::update_rect($screen, 0, 0, 640, 480);    

     return 0;
 }

 sub main
 {
     carp 'Unable to init SDL: '.SDL::get_error() if( SDL::init(SDL_INIT_VIDEO) &lt; 0);

     $screen = SDL::Video::set_video_mode( 640, 480, 32, SDL_SWSURFACE);

     carp 'Unable to set 640x480x32 video' . SDL::get_error() if(!$screen);

     while(1)
     {
         render();

         my $event = SDL::Event-&gt;new();

         while( SDL::Events::poll_event($event) )
         {
             my $type = $event-&gt;type;
             return 0 if( $type == SDL_KEYDOWN || $type == SDL_QUIT);
         }
         SDL::Events::pump_events();
     }
 }

 main();

 SDL::quit;

</pre>

</div>
<h2 id="unlock_surface">unlock_surface</h2>
<div id="unlock_surface_CONTENT">
<pre> SDL::Video::unlock_surface( $surface );

</pre>
<p>Surfaces that were previously locked using <a href="#lock_sruface">SDL::Video::lock_surface</a> must be unlocked with <code>SDL::Video::unlock_surface</code>. 
Surfaces should be unlocked as soon as possible.
<code>SDL::Video::unlock_surface</code> doesn't return anything.</p>
<p><strong>Note</strong>: Since 1.1.8, the surface locks are recursive. See <a href="#lock_sruface">SDL::Video::lock_surface</a> for more information. </p>

</div>
<h2 id="MUSTLOCK">MUSTLOCK</h2>
<div id="MUSTLOCK_CONTENT">
<pre> int SDL::Video::MUSTLOCK( $surface );

</pre>
<p><code>MUSTLOCK</code> returns <code>0</code> if the surface does not have to be locked during pixel operations, otherwise <code>1</code>.</p>

</div>
<h1 id="Screen_Updating_Functions">Screen Updating Functions</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="Screen_Updating_Functions_CONTENT">

</div>
<h2 id="set_clip_rect">set_clip_rect</h2>
<div id="set_clip_rect_CONTENT">
<pre> SDL::Video::set_clip_rect( $surface, $rect );

</pre>
<p>Sets the clipping rectangle for the given <a href="SDL-Surface">SDL::Surface</a>. When this surface is the destination of a blit, only the area within the clip 
rectangle will be drawn into.
The rectangle pointed to by rect will be clipped to the edges of the surface so that the clip rectangle for a surface can never fall 
outside the edges of the surface.
If rect is NULL the clipping rectangle will be set to the full size of the surface. 
<code>SDL::Video::set_clip_rect</code> doesn't returns anything.</p>

</div>
<h2 id="get_clip_rect">get_clip_rect</h2>
<div id="get_clip_rect_CONTENT">
<pre> SDL::Video::get_clip_rect( $surface, $rect );

</pre>
<p>Gets the clipping rectangle for the given <a href="SDL-Surface">SDL::Surface</a>. When this surface is the destination of a blit, only the area within the clip 
rectangle is drawn into.
The rectangle pointed to by rect will be filled with the clipping rectangle of the surface. 
<code>SDL::Video::get_clip_rect</code> doesn't returns anything;</p>
<pre> use SDL;
 use SDL::Video;
 use SDL::Rect;
 use SDL::Surface;

 my $screen_width  = 640;
 my $screen_height = 480;

 SDL::init(SDL_INIT_VIDEO);

 my $screen  = SDL::Video::set_video_mode($screen_width, $screen_height, 32, SDL_SWSURFACE);

 my $rect = SDL::Rect-&gt;new(0, 0, 0, 0);

 SDL::Video::get_clip_rect($screen, $rect);

 printf( &quot;rect is %d, %d, %d, %d\n&quot;, $rect-&gt;x, $rect-&gt;y, $rect-&gt;w, $rect-&gt;h);

 SDL::quit;

</pre>

</div>
<h2 id="blit_surface">blit_surface</h2>
<div id="blit_surface_CONTENT">
<pre> SDL::Video::blit_surface( $src_surface, $src_rect, $dest_surface, $dest_rect );

</pre>
<p>This performs a fast blit from the given source <a href="SDL-Surface">SDL::Surface</a> to the given destination <a href="SDL-Surface">SDL::Surface</a>.
The width and height in <code>src_surface</code> determine the size of the copied rectangle. Only the position is used in the <code>dst_rect</code> 
(the width and height are ignored). Blits with negative <code>dst_rect</code> coordinates will be clipped properly.
If <code>src_rect</code> is NULL, the entire surface is copied. If <code>dst_rect</code> is NULL, then the destination position (upper left corner) is (0, 0).
The final blit rectangle is saved in <code>dst_rect</code> after all clipping is performed (<code>src_rect</code> is not modified).
The blit function should not be called on a locked surface. I.e. when you use your own drawing functions you may need to lock a surface, 
but this is not the case with <code>SDL::Video::blit_surface</code>. Like most surface manipulation functions in SDL, it should not be used together 
with OpenGL.</p>
<p>The results of blitting operations vary greatly depending on whether <code>SDL_SRCALPHA</code> is set or not. See <a href="#set_alpha">SDL::Video::set_alpha</a> 
for an explanation of how this affects your results. Colorkeying and alpha attributes also interact with surface blitting.
<code>SDL::Video::blit_surface</code> doesn't returns anything.</p>
<p>For an example see <a href="#load_BMP">SDL::Video::load_BMP</a>.</p>

</div>
<h2 id="update_rect">update_rect</h2>
<div id="update_rect_CONTENT">
<pre> update_rect( $surface, $left, $top, $width, $height );

</pre>
<p>Makes sure the given area is updated on the given screen.  
The rectangle must be confined within the screen boundaries because there's no clipping.
update_rect doesn't returns any value.</p>
<p><strong>Note</strong>: This function should not be called while screen is locked by <a href="#lock_surface">SDL::Video::lock_surface</a></p>
<p><strong>Note2</strong>: If <code>x</code>, <code>y</code>, <code>width</code> and <code>height</code> are all equal to 0, <code>update_rect</code> will update the entire screen. </p>
<p>For an example see <a href="#SYNOPSIS">SYNOPSIS</a></p>

</div>
<h2 id="update_rects">update_rects</h2>
<div id="update_rects_CONTENT">
<pre> update_rects( $surface, @rects );

</pre>
<p>Makes sure the given list of rectangles is updated on the given screen. 
The rectangle must be confined within the screen boundaries because there's no clipping.
<code>update_rects</code> doesn't returns any value.</p>
<p><strong>Note</strong>: This function should not be called while screen is locked by <a href="#lock_surface">SDL::Video::lock_surface</a>.</p>
<p>Example:</p>
<pre> use SDL;
 use SDL::Video;
 use SDL::Surface;
 use SDL::Rect;

 # the size of the window box or the screen resolution if fullscreen
 my $screen_width   = 800;
 my $screen_height  = 600;

 SDL::init(SDL_INIT_VIDEO);

 # setting video mode
 my $screen_surface = SDL::Video::set_video_mode($screen_width, $screen_height, 32, SDL_SWSURFACE);

 # drawing the whole screen blue
 my $mapped_color   = SDL::Video::map_RGB($screen_surface-&gt;format(), 0, 0, 255); # blue
 SDL::Video::fill_rect($screen_surface, 
                       SDL::Rect-&gt;new(0, 0, $screen_width, $screen_height),
                       $mapped_color);

 my @rects = ();
 push(@rects, SDL::Rect-&gt;new(200,   0, 400, 600));
 push(@rects, SDL::Rect-&gt;new(  0, 150, 800, 300));

 # updating parts of the screen (should look like a cross)
 SDL::Video::update_rects($screen_surface, @rects);

 sleep(2);

 SDL::quit();

</pre>

</div>
<h2 id="flip">flip</h2>
<div id="flip_CONTENT">
<pre> $flip = SDL::Video::flip( $screen_surface );

</pre>
<p>On hardware that supports double-buffering, this function sets up a flip and returns. 
The hardware will wait for vertical retrace, and then swap video buffers before the next video surface blit or lock will return. 
On hardware that doesn't support double-buffering or if <code>SDL_SWSURFACE</code> was set, this is equivalent to calling 
<code>SDL::Video::update_rect( $screen, 0, 0, 0, 0 )</code>.</p>
<p>A software screen surface is also updated automatically when parts of a SDL window are redrawn, caused by overlapping windows or by 
restoring from an iconified state. As a result there is no proper double buffer behavior in windowed mode for a software screen, in 
contrast to a full screen software mode.</p>
<p>The <code>SDL_DOUBLEBUF</code> flag must have been passed to <a href="#set_video_mode">SDL::Video::set_video_mode</a>, when setting the video mode for this function 
to perform hardware flipping.</p>
<p><code>flip</code> returns <code>0</code> on success or <code>-1</code> on error.</p>
<p><strong>Note</strong>: If you want to swap the buffers of an initialized OpenGL context, use the function <a href="#GL_swap_buffers">SDL::Video::GL_swap_buffers</a> 
instead. </p>
<p>Example:</p>
<pre> use SDL;
 use SDL::Video;
 use SDL::Surface;

 # the size of the window box or the screen resolution if fullscreen
 my $screen_width   = 800;
 my $screen_height  = 600;

 SDL::init(SDL_INIT_VIDEO);

 # setting video mode
 my $screen_surface = SDL::Video::set_video_mode($screen_width, $screen_height, 32, SDL_DOUBLEBUF|SDL_FULLSCREEN);

 # do some video operations here

 # doing page flipping
 unless( SDL::Video::flip($screen_surface) == 0 )
 {
     printf( STDERR &quot;failed to swap buffers: %s\n&quot;, SDL::get_error() );
 }

 SDL::quit();

</pre>

</div>
<h1 id="Palette_Color_and_Pixel_Functions">Palette, Color and Pixel Functions</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="Palette_Color_and_Pixel_Functions_CO">

</div>
<h2 id="set_colors">set_colors</h2>
<div id="set_colors_CONTENT">
<pre> $set_colors = SDL::Video::set_colors( $surface, $start, $color1, $color2, ... )

</pre>
<p>Sets a portion of the colormap for the given 8-bit surface. </p>
<p>When surface is the surface associated with the current display, the display colormap will be updated with the requested colors. 
If <code>SDL_HWPALETTE</code> was set in <a href="#set_video_mode">SDL::Video::set_video_mode</a> flags, <code>SDL::Video::set_colors</code> will always return 1, and the 
palette is guaranteed to be set the way you desire, even if the window colormap has to be warped or run under emulation.
The color components of a <a href="SDL-Color">SDL::Color</a> structure are 8-bits in size, giving you a total of 2563 = 16777216 colors.
Palettized (8-bit) screen surfaces with the <code>SDL_HWPALETTE</code> flag have two palettes, a logical palette that is used for mapping blits to/from 
the surface and a physical palette (that determines how the hardware will map the colors to the display). 
<code>SDL::Video::set_colors</code> modifies both palettes (if present), and is equivalent to calling <a href="#set_palette">SDL::Video::set_palette</a> with the 
flags set to ( <code>SDL_LOGPAL | SDL_PHYSPAL</code> ). </p>
<p>If <code>surface</code> is not a palettized surface, this function does nothing, returning 0. 
If all of the colors were set as passed to <code>SDL::Video::set_colors</code>, it will return 1.
If not all the color entries were set exactly as given, it will return 0, and you should look at the surface palette to determine the 
actual color palette.</p>

</div>
<h2 id="set_palette">set_palette</h2>
<div id="set_palette_CONTENT">
<pre> $set_palette = set_palette( $surface, $flags, $start, $color1, $color2, ... );

</pre>
<p>Sets a portion of the palette for the given 8-bit surface.</p>
<p>Palettized (8-bit) screen surfaces with the <code>SDL_HWPALETTE</code> flag have two palettes, a logical palette that is used for mapping blits to/from 
the surface and a physical palette (that determines how the hardware will map the colors to the display). 
Non screen surfaces have a logical palette only. <a href="#blit">SDL::Video::blit</a> always uses the logical palette when blitting surfaces (if it has to 
convert between surface pixel formats). Because of this, it is often useful to modify only one or the other palette to achieve various 
special color effects (e.g., screen fading, color flashes, screen dimming).</p>
<p>This function can modify either the logical or physical palette by specifying <code>SDL_LOGPAL</code> or <code>SDL_PHYSPAL</code> the in the flags parameter.</p>
<p>When surface is the surface associated with the current display, the display colormap will be updated with the requested colors.
If <code>SDL_HWPALETTE</code> was set in <a href="#set_video_mode">SDL::Video::set_video_mode</a> flags, <code>SDL::Video::set_palette</code> will always return 1, and the 
palette is guaranteed to be set the way you desire, even if the window colormap has to be warped or run under emulation.
The color components of a <code>SDL::Color</code> structure are 8-bits in size, giving you a total of 2563 = 16777216 colors. </p>
<p>If <code>surface</code> is not a palettized surface, this function does nothing, returning <code>0</code>. If all of the colors were set as passed to <code>set_palette</code>,
it will return <code>1</code>. If not all the color entries were set exactly as given, it will return <code>0</code>, and you should look at the surface palette 
to determine the actual color palette.</p>

</div>
<h2 id="set_gamma">set_gamma</h2>
<div id="set_gamma_CONTENT">
<pre> $set_gamma = SDL::Video::set_gamma( $red_gamma, $green_gamma, $blue_gamma );

</pre>
<p>Sets the &quot;gamma function&quot; for the display of each color component. Gamma controls the brightness/contrast of colors displayed on the screen. 
A gamma value of 1.0 is identity (i.e., no adjustment is made).</p>
<p>This function adjusts the gamma based on the &quot;gamma function&quot; parameter, you can directly specify lookup tables for gamma adjustment 
with SDL::set_gamma_ramp.</p>
<p><strong>Note</strong>: Not all display hardware is able to change gamma.</p>
<p><code>SDL::Video::set_gamma</code> returns <code>-1</code> on error.</p>
<p><strong>Warning</strong>: Under Linux (X.org Gnome and Xfce), gamma settings affects the entire display (including the desktop)! </p>
<p>Example:</p>
<pre> use SDL;
 use SDL::Video;
 use SDL::Surface;
 use SDL::Rect;
 use Time::HiRes qw( usleep );

 # the size of the window box or the screen resolution if fullscreen
 my $screen_width   = 800;
 my $screen_height  = 600;

 SDL::init(SDL_INIT_VIDEO);

 # setting video mode
 my $screen_surface = SDL::Video::set_video_mode($screen_width, $screen_height, 32, SDL_SWSURFACE);

 # drawing something somewhere
 my $mapped_color   = SDL::Video::map_RGB($screen_surface-&gt;format(), 128, 128, 128); # gray
 SDL::Video::fill_rect($screen_surface, 
                       SDL::Rect-&gt;new($screen_width / 4, $screen_height / 4, $screen_width / 2, $screen_height / 2), 
                       $mapped_color);

 # update the whole screen
 SDL::Video::update_rect($screen_surface, 0, 0, $screen_width, $screen_height);

 usleep(500000);

 for(1..20)
 {
    SDL::Video::set_gamma( 1 - $_ / 20, 1, 1 );
	usleep(40000);
 }

 for(1..20)
 {
    SDL::Video::set_gamma( $_ / 20, 1, 1 );
	usleep(40000);
 }

 SDL::Video::set_gamma( 1, 1, 1 );

 usleep(500000);

 SDL::quit();

</pre>

</div>
<h2 id="get_gamma_ramp">get_gamma_ramp</h2>
<div id="get_gamma_ramp_CONTENT">
<pre> $get_gamma_ramp = SDL::Video::get_gamma_ramp( \@red_table, \@green_table, \@blue_table );

</pre>
<p>Gets the gamma translation lookup tables currently used by the display. Each table is an array of 256 Uint16 values.
<code>SDL::Video::get_gamma_ramp</code> returns -1 on error.</p>
<pre> use SDL;
 use SDL::Video;

 SDL::init(SDL_INIT_VIDEO);

 my (@red, @green, @blue);

 my $ret = SDL::Video::get_gamma_ramp( \@red, \@green, \@blue );

 if( -1 == $ret )
 {
     print( &quot;an error occoured&quot; );
 }
 else
 {
     printf( &quot;for gamma = 1.0: red=0x%04X, green=0x%04X, blue=0x%04X\n&quot;, $red[255], $green[255], $blue[255] );
     printf( &quot;for gamma = 0.5: red=0x%04X, green=0x%04X, blue=0x%04X\n&quot;, $red[127], $green[127], $blue[127] );
     printf( &quot;for gamma = 0.0: red=0x%04X, green=0x%04X, blue=0x%04X\n&quot;, $red[0],   $green[0],   $blue[0]   );
 }

 SDL::quit();

</pre>

</div>
<h2 id="set_gamma_ramp">set_gamma_ramp</h2>
<div id="set_gamma_ramp_CONTENT">
<pre> $set_gamma_ramp = SDL::Video::set_gamma_ramp( \@red_table, \@green_table, \@blue_table );

</pre>
<p>Sets the gamma lookup tables for the display for each color component. Each table is an array ref of 256 Uint16 values, representing a 
mapping between the input and output for that channel.
The input is the index into the array, and the output is the 16-bit gamma value at that index, scaled to the output color precision. 
You may pass NULL to any of the channels to leave them unchanged.</p>
<p>This function adjusts the gamma based on lookup tables, you can also have the gamma calculated based on a &quot;gamma function&quot; parameter 
with <a href="#set_gamma">SDL::Video::set_gamma</a>.</p>
<p>Not all display hardware is able to change gamma. 
<code>SDL::Video::set_gamma_ramp</code> returns <code>-1</code> on error (or if gamma adjustment is not supported).</p>
<p>Example:</p>
<pre> use SDL;
 use SDL::Video;

 SDL::init(SDL_INIT_VIDEO);

 my (@red, @green, @blue);

 my $ret = SDL::Video::get_gamma_ramp( \@red, \@green, \@blue );

 $red[127] = 0xFF00;

    $ret = SDL::Video::set_gamma_ramp( \@red, \@green, \@blue );

    $ret = SDL::Video::get_gamma_ramp( \@red, \@green, \@blue );

 if( -1 == $ret )
 {
     print( &quot;an error occoured&quot; );
 }
 else
 {
     printf( &quot;for gamma = 1.0: red=0x%04X, green=0x%04X, blue=0x%04X\n&quot;, $red[255], $green[255], $blue[255] );
     printf( &quot;for gamma = 0.5: red=0x%04X, green=0x%04X, blue=0x%04X\n&quot;, $red[127], $green[127], $blue[127] );
     printf( &quot;for gamma = 0.0: red=0x%04X, green=0x%04X, blue=0x%04X\n&quot;, $red[0],   $green[0],   $blue[0]   );
 }

 SDL::quit();

</pre>

</div>
<h2 id="map_RGB">map_RGB</h2>
<div id="map_RGB_CONTENT">
<pre> $pixel = SDL::Video::map_RGB( $pixel_format, $r, $g, $b );

</pre>
<p>Maps the RGB color value to the specified <a href="SDL-PixelFormat">SDL::PixelFormat</a> and returns the pixel value as a 32-bit int.
If the format has a palette (8-bit) the index of the closest matching color in the palette will be returned.
If the specified pixel format has an alpha component it will be returned as all 1 bits (fully opaque). </p>
<p><code>SDL::Video::map_RGB</code> returns a pixel value best approximating the given RGB color value for a given pixel format.
If the <a href="SDL-PixelFormat">SDL::PixelFormat</a>'s  bpp (color depth) is less than 32-bpp then the unused upper bits of the return value can safely be ignored 
(e.g., with a 16-bpp format the return value can be assigned to a Uint16, and similarly a Uint8 for an 8-bpp format).</p>
<pre> use SDL;
 use SDL::Video;
 use SDL::PixelFormat;
 use SDL::Surface;

 SDL::init(SDL_INIT_VIDEO);

 my $screen_surface = SDL::Video::set_video_mode(640, 480, 16, SDL_SWSURFACE);
 #                                                          ^-- 16 bits per pixel

 $r = 0x9C;
 $g = 0xDC;
 $b = 0x67;

 printf( &quot;for 24bpp it is: 0x%02X 0x%02X 0x%02X\n&quot;, $r, $g, $b);

 my $_16bit = SDL::Video::map_RGB( $screen_surface-&gt;format, $r, $g, $b );

 # 16bpp is 5 bits red, 6 bits green and 5 bits blue
 # we will obtain the values for each color and calculating them back to 24/32bit color system
 ($r, $g, $b) = @{ SDL::Video::get_RGB( $screen_surface-&gt;format, $_16bit ) };

 printf( &quot;for 16bpp it is: 0x%02X 0x%02X 0x%02X\n&quot;, $r, $g, $b );

 # so color #9CDC67 becomes #9CDF63

 SDL::quit();

</pre>

</div>
<h2 id="map_RGBA">map_RGBA</h2>
<div id="map_RGBA_CONTENT">
<pre> $pixel = SDL::Video::map_RGB( $pixel_format, $r, $g, $b, $a );

</pre>
<p>Maps the RGBA color value to the specified <a href="SDL-PixelFormat">SDL::PixelFormat</a> and returns the pixel value as a 32-bit int.
If the format has a palette (8-bit) the index of the closest matching color in the palette will be returned.
If the specified pixel format has no alpha component the alpha value will be ignored (as it will be in formats with a palette). </p>
<p>A pixel value best approximating the given RGBA color value for a given pixel format.
If the pixel format bpp (color depth) is less than 32-bpp then the unused upper bits of the return value can safely be ignored (e.g., 
with a 16-bpp format the return value can be assigned to a Uint16, and similarly a Uint8 for an 8-bpp format).</p>

</div>
<h2 id="get_RGB">get_RGB</h2>
<div id="get_RGB_CONTENT">
<pre> $rgb_array_ref = SDL::Video::get_RGB( $pixel_format, $pixel );

</pre>
<p>Returns RGB values from a pixel in the specified pixel format. The pixel is an integer (e.g. 16bit RGB565, 24/32bit RGB888).
This function uses the entire 8-bit [0..255] range when converting color components from pixel formats with less than 8-bits per RGB 
component (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff, 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).</p>
<p>For an example see <a href="#map_RGB">SDL::Video::map_RGB</a>.</p>

</div>
<h2 id="get_RGBA">get_RGBA</h2>
<div id="get_RGBA_CONTENT">
<pre> $rgba_array_ref = SDL::Video::get_RGBA( $pixel_format, $pixel );

</pre>
<p>Gets RGBA values from a pixel in the specified pixel format. 
This function uses the entire 8-bit [0..255] range when converting color components from pixel formats with less than 8-bits per RGB 
component (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff, 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).</p>
<p>If the surface has no alpha component, the alpha will be returned as 0xff (100% opaque). </p>

</div>
<h1 id="GL_Methods">GL Methods</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="GL_Methods_CONTENT">

</div>
<h2 id="GL_load_library">GL_load_library</h2>
<div id="GL_load_library_CONTENT">
<pre> $gl_load_lib = SDL::Video::GL_load_library( 'path/to/static/glfunctions.dll' );

</pre>
<p>If you wish, you may load the OpenGL library from the given path at runtime, this must be done before 
<a href="#set_video_mode">SDL::Video::set_video_mode</a> is called. You must then use <a href="#GL_get_proc_address">SDL::Video::GL_get_proc_address</a> to retrieve 
function pointers to GL functions. </p>
<p><code>GL_load_library</code> returns <code>0</code> on success or <code>-1</code> or error.</p>

</div>
<h2 id="GL_get_proc_address">GL_get_proc_address</h2>
<div id="GL_get_proc_address_CONTENT">
<pre> $proc_address = SDL::Video::GL_get_proc_address( $proc );

</pre>
<p>Returns the address of the GL function proc, or NULL if the function is not found. If the GL library is loaded at runtime, with 
<a href="#GL_load_library">SDL::Video::GL_load_library</a>, then all GL functions must be retrieved this way. Usually this is used to retrieve function 
pointers to OpenGL extensions. Note that this function needs an OpenGL context to function properly, so it should be called after 
<a href="#set_video_mode">SDL::Video::set_video_mode</a> has been called (with the <code>SDL_OPENGL</code> flag).</p>
<p>It returns undef if the function is not found.</p>
<p>Example:</p>
<pre> my $has_multitexture = 1;

 # Get function pointer
 $gl_active_texture_ARB_ptr = SDL::Video::GL_get_proc_address(&quot;glActiveTextureARB&quot;);

 # Check for a valid function ptr
 unless($gl_active_texture_ARB_ptr)
 {
     printf( STDERR &quot;Multitexture Extensions not present.\n&quot; );
     $has_multitexture = 0;
 }

 $gl_active_texture_ARB_ptr(GL_TEXTURE0_ARB) if $has_multitexture;

</pre>

</div>
<h2 id="GL_get_attribute">GL_get_attribute</h2>
<div id="GL_get_attribute_CONTENT">
<pre> $value = SDL::Video::GL_get_attribute( $attr );

</pre>
<p>It returns SDL/OpenGL attribute <code>attr</code>. This is useful after a call to <a href="#set_video_mode">SDL::Video::set_video_mode</a> to check whether your 
attributes have been set as you expected. 
<code>SDL::Video::GL_get_attribute</code> returns <code>undef</code> if the attribute is not found.</p>
<p>Example:</p>
<pre> print( SDL::Video::GL_set_attribute(SDL_GL_RED_SIZE) );

</pre>

</div>
<h2 id="GL_set_attribute">GL_set_attribute</h2>
<div id="GL_set_attribute_CONTENT">
<pre> $set_attr = SDL::Video::GL_set_attribute( $attr, $value );

</pre>
<p>This function sets the given OpenGL attribute <code>attr</code> to <code>value</code>. The requested attributes will take effect after a call to 
<a href="#set_video_mode">SDL::Video::set_video_mode</a>.
You should use <code>SDL::Video::GL_get_attribute|/GL_get_attribute</code> to check the values after a <a href="#set_video_mode">SDL::Video::set_video_mode</a> call, 
since the values obtained can differ from the requested ones.</p>
<p>Available attributes:</p>
<ul>
		<li><code>SDL_GL_RED_SIZE</code>	</li>
		<li><code>SDL_GL_GREEN_SIZE</code>	</li>
		<li><code>SDL_GL_BLUE_SIZE</code>	</li>
		<li><code>SDL_GL_ALPHA_SIZE</code>	</li>
		<li><code>SDL_GL_BUFFER_SIZE</code>	</li>
		<li><code>SDL_GL_DOUBLEBUFFER</code>	</li>
		<li><code>SDL_GL_DEPTH_SIZE</code>	</li>
		<li><code>SDL_GL_STENCIL_SIZE</code>	</li>
		<li><code>SDL_GL_ACCUM_RED_SIZE</code>	</li>
		<li><code>SDL_GL_ACCUM_GREEN_SIZE</code>	</li>
		<li><code>SDL_GL_ACCUM_BLUE_SIZE</code>	</li>
		<li><code>SDL_GL_ACCUM_ALPHA_SIZE</code>	</li>
		<li><code>SDL_GL_STEREO</code>	</li>
		<li><code>SDL_GL_MULTISAMPLEBUFFERS</code>	</li>
		<li><code>SDL_GL_MULTISAMPLESAMPLES</code>	</li>
		<li><code>SDL_GL_ACCELERATED_VISUAL</code>	</li>
		<li><code>SDL_GL_SWAP_CONTROL</code></li>
</ul>

<p><code>GL_set_attribute</code> returns <code>0</code> on success or <code>-1</code> on error.</p>
<p><strong>Note</strong>: The <code>SDL_DOUBLEBUF</code> flag is not required to enable double buffering when setting an OpenGL video mode. Double buffering is enabled 
or disabled using the <code>SDL_GL_DOUBLEBUFFER</code> attribute. </p>
<p>Example:</p>
<pre> SDL::Video::GL_set_attribute(SDL_GL_RED_SIZE, 5);

</pre>

</div>
<h2 id="GL_swap_buffers">GL_swap_buffers</h2>
<div id="GL_swap_buffers_CONTENT">
<pre> SDL::Video::GL_swap_buffers();

</pre>
<p>Swap the OpenGL buffers, if double-buffering is supported.
<code>SDL::Video::GL_swap_buffers</code> doesn't returns any value.</p>

</div>
<h1 id="Video_Overlay_Functions">Video Overlay Functions</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="Video_Overlay_Functions_CONTENT">
<p>see <a href="SDL-Overlay">SDL::Overlay</a> </p>

</div>
<h2 id="lock_YUV_overlay">lock_YUV_overlay</h2>
<div id="lock_YUV_overlay_CONTENT">
<pre> $lock_overlay = SDL::Video::lock_YUV_overlay( $overlay );

</pre>
<p>Much the same as <a href="#lock_surface">SDL::Video::lock_surface</a>, <code>lock_YUV_overlay</code> locks the overlay for direct access to pixel data.
It returns <code>0</code> on success or <code>-1</code> on error.</p>

</div>
<h2 id="unlock_YUV_overlay">unlock_YUV_overlay</h2>
<div id="unlock_YUV_overlay_CONTENT">
<pre> SDL::Video::unlock_YUV_overlay( $overlay );

</pre>
<p>The opposite to <a href="#sock_YUV_overlay">SDL::Video::lock_YUV_overlay</a>. Unlocks a previously locked overlay. An overlay must be unlocked before it 
can be displayed. <code>unlock_YUV_overlay</code> does not return anything.</p>

</div>
<h2 id="display_YUV_overlay">display_YUV_overlay</h2>
<div id="display_YUV_overlay_CONTENT">
<pre> $display_overlay = SDL::Video::display_YUV_overlay( $overlay, $dstrect );

</pre>
<p>Blit the overlay to the display surface specified when the overlay was created. The <a href="SDL-Rect">SDL::Rect</a> structure, <code>dstrect</code>, specifies a rectangle 
on the display where the overlay is drawn. The <code>x</code> and <code>y</code> fields of <code>dstrect</code> specify the upper left location in display coordinates. 
The overlay is scaled (independently in x and y dimensions) to the size specified by dstrect, and is <code>optimized</code> for 2x scaling</p>
<p>It returns <code>0</code> on success or <code>-1</code> on error.</p>

</div>
<h1 id="Window_Management_Functions">Window Management Functions</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="Window_Management_Functions_CONTENT">

</div>
<h2 id="wm_set_caption">wm_set_caption</h2>
<div id="wm_set_caption_CONTENT">
<pre> SDL::Video::wm_set_caption( $title, $icon );

</pre>
<p>Sets the title-bar and icon name of the display window.</p>
<p><code>title</code> is a UTF-8 encoded null-terminated string which will serve as the window title (the text at the top of the window). The function 
does not change the string. You may free the string after the function returns.</p>
<p><code>icon</code> is a UTF-8 encoded null-terminated string which will serve as the iconified window title (the text which is displayed in the menu 
bar or desktop when the window is minimized). As with title this string may be freed after the function returns. </p>
<p>Example:</p>
<pre> use SDL;
 use SDL::Video;
 use SDL::Surface;

 SDL::init(SDL_INIT_VIDEO);

 my $screen  = SDL::Video::set_video_mode(640, 480, 32, SDL_SWSURFACE);

 SDL::Video::wm_set_caption( 'maximized title', 'minimized title' );

 sleep(2);

 SDL::quit;

</pre>

</div>
<h2 id="wm_get_caption">wm_get_caption</h2>
<div id="wm_get_caption_CONTENT">
<pre> SDL::Video::wm_get_caption( $title, $icon );

</pre>
<p>Retrieves the title-bar and icon name of the display window.</p>
<p>Example:</p>
<pre> use SDL;
 use SDL::Video;
 use SDL::Surface;

 SDL::init(SDL_INIT_VIDEO);

 my $screen  = SDL::Video::set_video_mode(640, 480, 32, SDL_SWSURFACE);

 SDL::Video::wm_set_caption( 'maximized title', 'minimized title' );

 my ($title, $icon) = @{ SDL::Video::wm_get_caption() };

 printf( &quot;title is '%s' and icon is '%s'\n&quot;, $title, $icon );

 SDL::quit;

</pre>

</div>
<h2 id="wm_set_icon">wm_set_icon</h2>
<div id="wm_set_icon_CONTENT">
<pre> SDL::Video::wm_set_icon( $icon );

</pre>
<p>Sets the icon for the display window. Win32 icons must be 32x32.</p>
<p>This function must be called before the first call to <a href="#set_video_mode">SDL::Video::set_video_mode</a>. Note that this means <a href="SDL-Image">SDL::Image</a> 
cannot be used.</p>
<p>The shape is determined by the colorkey or alpha channel of the icon, if any. If neither of those are present, the icon is made opaque 
(no transparency).</p>
<p>Example:</p>
<pre> SDL::Video::wm_set_icon(SDL::Video::load_BMP(&quot;icon.bmp&quot;));

</pre>
<p>Another option, if your icon image does not have a colorkey set, is to use the SDL::Video::set_color_key to set the transparency.</p>
<p>Example:</p>
<pre> my $image = SDL::Video::load_BMP(&quot;icon.bmp&quot;);

 my colorkey = SDL::Video::map_RGB($image-&gt;format, 255, 0, 255); # specify the color that will be transparent

 SDL::Video::set_color_key($image, SDL_SRCCOLORKEY, $colorkey);              

 SDL::Video::wm_set_icon($image);

</pre>

</div>
<h2 id="wm_grab_input">wm_grab_input</h2>
<div id="wm_grab_input_CONTENT">
<pre> $grab_mode = SDL::Video::wm_grab_input($mode);

</pre>
<p>Grabbing means that the mouse is confined to the application window, and nearly all keyboard input is passed directly to the application, 
and not interpreted by a window manager, if any.</p>
<p>When mode is <code>SDL_GRAB_QUERY</code> the grab mode is not changed, but the current grab mode is returned.</p>
<p><code>mode</code> and the return value of <code>wm_grab_input</code> can be one of the following:</p>
<ul>
		<li><code>SDL_GRAB_QUERY</code>	</li>
		<li><code>SDL_GRAB_OFF</code>	</li>
		<li><code>SDL_GRAB_ON</code></li>
</ul>


</div>
<h2 id="wm_iconify_window">wm_iconify_window</h2>
<div id="wm_iconify_window_CONTENT">
<pre> $iconify_window = SDL::Video::wm_iconify_window();

</pre>
<p>If the application is running in a window managed environment SDL attempts to iconify/minimise it. If <code>wm_iconify_window</code> is successful, 
the application will receive a <code>SDL_APPACTIVE</code> loss event (see Application visibility events at <a href="SDL-Event">SDL::Event</a>).</p>
<p>Returns non-zero on success or 0 if iconification is not supported or was refused by the window manager. </p>
<p>Example:</p>
<pre> use SDL;
 use SDL::Video;
 use SDL::Surface;

 SDL::init(SDL_INIT_VIDEO);

 my $screen  = SDL::Video::set_video_mode(640, 480, 32, SDL_SWSURFACE);

 sleep(2);

 SDL::Video::wm_iconify_window();

 sleep(2); 

 SDL::quit;

</pre>

</div>
<h2 id="wm_toggle_fullscreen">wm_toggle_fullscreen</h2>
<div id="wm_toggle_fullscreen_CONTENT">
<pre> $toggle = SDL::Video::wm_toggle_fullscreen( $surface );

</pre>
<p>Toggles the application between windowed and fullscreen mode, if supported. (X11 is the only target currently supported, BeOS support 
is experimental).</p>

</div>
<h1 id="AUTHOR">AUTHOR</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="AUTHOR_CONTENT">
<p>magnet, Tobias Leich (FROGGS)</p>

</div>
<h1 id="SEE_ALSO">SEE ALSO</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="SEE_ALSO_CONTENT">

</div>
<h2 id="Category_Objects">Category Objects</h2>
<div id="Category_Objects_CONTENT">
<p><a href="SDL-Surface">SDL::Surface</a>, <a href="SDL-Overlay">SDL::Overlay</a>, <a href="SDL-Color">SDL::Color</a>,
<a href="SDL-Rect">SDL::Rect</a>, <a href="SDL-Palette">SDL::Palette</a>, <a href="SDL-PixelFormat">SDL::PixelFormat</a>, 
<a href="SDL-VideoInfo">SDL::VideoInfo</a></p>

</div>
</div>